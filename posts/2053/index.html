<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    探索c-capnproto用于嵌入式工程的可行性
  
</title>

<meta name="description" content="当前MCU上与外部交互的应用层协议，一般都是开发者手动编、解的简单二进制协议；用到序列化格式来做协议的需求，是IoT快速发展后才开始的，比如一些设备会用到JSON。 手头维护的硬件产品，应用协议已经很复杂了，一个二进制协议，实现、写文档都是麻烦事。所以我一直在探索一个快速、适合嵌入式应用的序列化格式方案，试图减轻开发负担。 Cap’n Proto是种快速数据交换格式，目标是数据快速交换、做RPC，">
<meta property="og:type" content="article">
<meta property="og:title" content="探索c-capnproto用于嵌入式工程的可行性">
<meta property="og:url" content="http://noodlefighter.com/posts/2053/index.html">
<meta property="og:site_name" content="Noodlefighter&#39;s HP">
<meta property="og:description" content="当前MCU上与外部交互的应用层协议，一般都是开发者手动编、解的简单二进制协议；用到序列化格式来做协议的需求，是IoT快速发展后才开始的，比如一些设备会用到JSON。 手头维护的硬件产品，应用协议已经很复杂了，一个二进制协议，实现、写文档都是麻烦事。所以我一直在探索一个快速、适合嵌入式应用的序列化格式方案，试图减轻开发负担。 Cap’n Proto是种快速数据交换格式，目标是数据快速交换、做RPC，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-27T00:00:00.000Z">
<meta property="article:modified_time" content="2021-11-27T17:58:27.365Z">
<meta property="article:author" content="Noodlefighter">
<meta property="article:tag" content="嵌入式软件">
<meta name="twitter:card" content="summary">


  <link rel="alternative" href="/atom.xml" title="Noodlefighter&#39;s HP" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">



<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">


<link rel="stylesheet" href="/styles/main.css">







<style type="text/css">
.spoiler {
  display: inline-flex;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Noodlefighter&#39;s HP</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Noodlefighter&#39;s HP</a></h1>
    
      <p class="subtitle">
        ——蠢战士
      </p>
    
    <div class="info">
      <div class="content">
        
          <div class="description">开坑不填是生活中一大乐趣.</div>
        
        
          <div class="author">Noodlefighter</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about_me"><img src="/favicon.png"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li>
                <a href="http://wiki.noodlefighter.com/" title="个人知识库Wiki" target="_blank" rel="noopener">个人知识库Wiki</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">文章分类</a>
                <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/%E4%BD%9C%E5%93%81/">作品</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/%E5%85%B6%E4%BB%96/">其他</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">15</span></li><li class="category-list-item"><a class="category-list-link" href="/%E5%BA%94%E7%94%A8/">应用</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/%E6%8A%80%E6%9C%AF/">技术</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/%E6%96%B9%E6%B3%95/">方法</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/%E6%9D%82%E8%B0%88/">杂谈</a><span class="category-list-count">7</span></li></ul>
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/macos/" rel="tag">macos</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/web/" rel="tag">web</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/windows/" rel="tag">windows</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6/" rel="tag">嵌入式软件</a><span class="tag-list-count">22</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%85%B7/" rel="tag">工具</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/" rel="tag">方法论</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97/" rel="tag">日志</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9E%8B/" rel="tag">模型</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%8C%E8%AF%8D/" rel="tag">歌词</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E5%AD%90/" rel="tag">电子</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/" rel="tag">碎碎念</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6/" rel="tag">计算机软件</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" rel="tag">软件工程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" rel="tag">输入法</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%AE%E7%9B%98/" rel="tag">键盘</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%BA%BB%E5%B0%86/" rel="tag">麻将</a><span class="tag-list-count">1</span></li></ul>
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/">2018</a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/">2014</a><span class="archive-list-count">3</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/about_me" title="关于我" external="false">关于我</a>
              </li>
            
          
            
              <li>
                <a href="https://weibo.com/noodlefighter" title="My Weibo" target="_blank" rel="noopener">My Weibo</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/noodlefighter" title="My Github" target="_blank" rel="noopener">My Github</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li class="tag-list-container">
                <a href="javascript:;">友情链接</a>
                
                  <ul class="tag-list">
                    
                      <div class="tag-list-item">
                        <a href="https://www.kozzzx.com/" title="kozzzx" target="_blank" rel="noopener">kozzzx</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://yukoamamiya.blogspot.com/" title="雨宮優子" target="_blank" rel="noopener">雨宮優子</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://yihuishou.github.io/" title="挥手骑士" target="_blank" rel="noopener">挥手骑士</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://www.chenxublog.com/" title="晨旭的博客" target="_blank" rel="noopener">晨旭的博客</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://katyusha.net/" title="卡秋莎的小窝" target="_blank" rel="noopener">卡秋莎的小窝</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://stgapr.github.io/" title="核桃" target="_blank" rel="noopener">核桃</a>
                      </div>
                    
                      <div class="tag-list-item">
                        <a href="https://yinyisheng.github.io/" title="生活家" target="_blank" rel="noopener">生活家</a>
                      </div>
                    
                  </ul>
                
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          <article id="post-工具-探索c-capnproto用于嵌入式工程的可行性" class="article article-type-post">
  
    <h1 class="article-header">
      探索c-capnproto用于嵌入式工程的可行性
    </h1>
  
  

  <div class="article-info">
    <span class="article-date">
  2021-05-27
</span>

  </div>
  <div class="article-entry">
    <p>当前MCU上与外部交互的应用层协议，一般都是开发者手动编、解的简单二进制协议；用到序列化格式来做协议的需求，是IoT快速发展后才开始的，比如一些设备会用到JSON。</p>
<p>手头维护的硬件产品，应用协议已经很复杂了，一个二进制协议，实现、写文档都是麻烦事。所以我一直在探索一个快速、适合嵌入式应用的序列化格式方案，试图减轻开发负担。</p>
<p>Cap’n Proto是种快速数据交换格式，目标是数据快速交换、做RPC，由于它的格式在内存中能直接读、写，省略了编、解码的开销，所以相比google的protobuf快。c-capnproto是它在C中的实现。</p>
<p>这篇文章的目标是：研究c-capnproto的基本用法、评估将它用于嵌入式环境的可能性。</p>
<span id="more"></span>

<h2 id="什么是cap’n-proto"><a href="#什么是cap’n-proto" class="headerlink" title="什么是cap’n proto"></a>什么是cap’n proto</h2><p><a target="_blank" rel="noopener" href="https://capnproto.org/">它的首页</a>上已经说得很清楚了，翻译一段：</p>
<blockquote>
<p>Cap’n Proto是一种快速的数据交换格式、基于功能（译注：原文capability-based，指各组件专注于单一功能的架构设计）的RPC系统。 它就像JSON，但并不是二进制的，或者说像protobuf，但速度更快。实际上，在基准测试中，Cap’n Proto比协议缓冲区的无限时间快。</p>
<p>当然，这个基准测试是不公平的。它只会测量在内存中对消息进行编码和解码的时间，由于没有编码/解码步骤，因此Cap’n Proto得分很高。 Cap’n Proto编码既适合作为数据交换格式，又适合作为内存表示形式，因此一旦在内存里构建了结构，就可以直接将数据直接写到磁盘上！</p>
</blockquote>
<ul>
<li>不像JSON一样用字符串自解释，而是像protobuf一样用一张额外的“表”（就是.capnp文件）来表示数据中每段内容的意义</li>
<li>储存结构像C中的结构体在内存中的样子，但它又是平台无关的，同时支持“pack”功能在传输的时候简单压缩以节省带宽</li>
</ul>
<h2 id="c-capnproto"><a href="#c-capnproto" class="headerlink" title="c-capnproto"></a>c-capnproto</h2><p><a target="_blank" rel="noopener" href="https://github.com/opensourcerouting/c-capnproto">c-capnproto项目</a>是Cap’n Proto的C实现，它包括c库和capnp文件翻译器。</p>
<p>用户的程序在运行期间不解析.capnp文件，而是编译前先把.capnp文件翻译成对应C源文件，通过生成的函数、结构体对数据进行操作。比如官方例子 <code>addressbook.capnp</code>：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> {</span></span><br><span class="line">  id @<span class="number">0</span> :UInt32;</span><br><span class="line">  name @<span class="number">1</span> :Text;</span><br><span class="line">  email @<span class="number">2</span> :Text;</span><br><span class="line">  phones @<span class="number">3</span> :List(PhoneNumber);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PhoneNumber</span> {</span></span><br><span class="line">    number @<span class="number">0</span> :Text;</span><br><span class="line">    type @<span class="number">1</span> :Type;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Type</span> {</span></span><br><span class="line">      mobile @<span class="number">0</span>;</span><br><span class="line">      home @<span class="number">1</span>;</span><br><span class="line">      work @<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  ...略</span><br><span class="line">}c</span><br></pre></td></tr></tbody></table></figure>

<p>生成出来的<code>addressbook.capnp.c</code>中，对于Person能看到对应操作函数：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person_ptr <span class="title">new_Person</span><span class="params">(struct capn_segment*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_Person</span><span class="params">(struct Person*, Person_ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_Person</span><span class="params">(<span class="keyword">const</span> struct Person*, Person_ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_Person</span><span class="params">(struct Person*, Person_list, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_Person</span><span class="params">(<span class="keyword">const</span> struct Person*, Person_list, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">Person_get_id</span><span class="params">(Person_ptr p)</span></span>;</span><br><span class="line"><span class="function">capn_text <span class="title">Person_get_name</span><span class="params">(Person_ptr p)</span></span>;</span><br><span class="line"><span class="function">capn_text <span class="title">Person_get_email</span><span class="params">(Person_ptr p)</span></span>;</span><br><span class="line"><span class="function">Person_PhoneNumber_list <span class="title">Person_get_phones</span><span class="params">(Person_ptr p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person_set_id</span><span class="params">(Person_ptr p, <span class="keyword">uint32_t</span> id)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person_set_name</span><span class="params">(Person_ptr p, capn_text name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person_set_email</span><span class="params">(Person_ptr p, capn_text email)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Person_set_phones</span><span class="params">(Person_ptr p, Person_PhoneNumber_list phones)</span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>这些函数要怎么用呢，例子<code>example-test.cpp</code>，将Person数据序列化，再反序列化：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">TEST(Examples, RoundTripPerson) {</span><br><span class="line">  <span class="keyword">uint8_t</span> buf[<span class="number">4096</span>];</span><br><span class="line">  <span class="keyword">ssize_t</span> sz = <span class="number">0</span>; <span class="comment">// size</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">"Firstname Lastname"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *email = <span class="string">"username@domain.com"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *school = <span class="string">"of life"</span>;</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">capn</span> <span class="title">c</span>;</span></span><br><span class="line">    capn_init_malloc(&amp;c);</span><br><span class="line">    capn_ptr cr = capn_root(&amp;c);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *<span class="title">cs</span> =</span> cr.seg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set initial object in `p`.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p</span> =</span> {</span><br><span class="line">      .id = <span class="number">17</span>,</span><br><span class="line">      .name = chars_to_text(name),</span><br><span class="line">      .email = chars_to_text(email),</span><br><span class="line">    };</span><br><span class="line">    p.employment_which = Person_employment_school;</span><br><span class="line">    p.employment.school = chars_to_text(school);</span><br><span class="line"></span><br><span class="line">    p.phones = new_Person_PhoneNumber_list(cs, <span class="number">2</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person_PhoneNumber</span> <span class="title">pn0</span> =</span> {</span><br><span class="line">      .number = chars_to_text(<span class="string">"123"</span>),</span><br><span class="line">      .type = Person_PhoneNumber_Type_work,</span><br><span class="line">    };</span><br><span class="line">    set_Person_PhoneNumber(&amp;pn0, p.phones, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person_PhoneNumber</span> <span class="title">pn1</span> =</span> {</span><br><span class="line">      .number = chars_to_text(<span class="string">"234"</span>),</span><br><span class="line">      .type = Person_PhoneNumber_Type_home,</span><br><span class="line">    };</span><br><span class="line">    set_Person_PhoneNumber(&amp;pn1, p.phones, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Person_ptr pp = new_Person(cs);</span><br><span class="line">    write_Person(&amp;p, pp);</span><br><span class="line">    <span class="keyword">int</span> setp_ret = capn_setp(capn_root(&amp;c), <span class="number">0</span>, pp.p);</span><br><span class="line">    ASSERT_EQ(<span class="number">0</span>, setp_ret);</span><br><span class="line">    sz = capn_write_mem(&amp;c, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span> <span class="comment">/* packed */</span>);</span><br><span class="line">    capn_free(&amp;c);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  {</span><br><span class="line">    <span class="comment">// Deserialize `buf[0..sz-1]` to `rp`.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">capn</span> <span class="title">rc</span>;</span></span><br><span class="line">    <span class="keyword">int</span> init_mem_ret = capn_init_mem(&amp;rc, buf, sz, <span class="number">0</span> <span class="comment">/* packed */</span>);</span><br><span class="line">    ASSERT_EQ(<span class="number">0</span>, init_mem_ret);</span><br><span class="line">    Person_ptr rroot;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">rp</span>;</span></span><br><span class="line">    rroot.p = capn_getp(capn_root(&amp;rc), <span class="number">0</span> <span class="comment">/* off */</span>, <span class="number">1</span> <span class="comment">/* resolve */</span>);</span><br><span class="line">    read_Person(&amp;rp, rroot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert deserialized values in `rp`</span></span><br><span class="line">    EXPECT_EQ(rp.id, (<span class="keyword">uint32_t</span>) <span class="number">17</span>);</span><br><span class="line">    EXPECT_CAPN_TEXT_EQ(name, rp.name);</span><br><span class="line">    EXPECT_CAPN_TEXT_EQ(email, rp.email);</span><br><span class="line"></span><br><span class="line">    EXPECT_EQ(rp.employment_which, Person_employment_school);</span><br><span class="line">    EXPECT_CAPN_TEXT_EQ(school, rp.employment.school);</span><br><span class="line"></span><br><span class="line">    EXPECT_EQ(<span class="number">2</span>, capn_len(rp.phones));</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person_PhoneNumber</span> <span class="title">rpn0</span>;</span></span><br><span class="line">    get_Person_PhoneNumber(&amp;rpn0, rp.phones, <span class="number">0</span>);</span><br><span class="line">    EXPECT_CAPN_TEXT_EQ(<span class="string">"123"</span>, rpn0.number);</span><br><span class="line">    EXPECT_EQ(rpn0.type, Person_PhoneNumber_Type_work);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person_PhoneNumber</span> <span class="title">rpn1</span>;</span></span><br><span class="line">    get_Person_PhoneNumber(&amp;rpn1, rp.phones, <span class="number">1</span>);</span><br><span class="line">    EXPECT_CAPN_TEXT_EQ(<span class="string">"234"</span>, rpn1.number);</span><br><span class="line">    EXPECT_EQ(rpn1.type, Person_PhoneNumber_Type_home);</span><br><span class="line"></span><br><span class="line">    capn_free(&amp;rc);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>读例子可了解到的信息：</p>
<ul>
<li>在这个实现中，数据段都是通过<code>capn_ptr</code>来引用的，比如<code>Person_ptr</code>本质就是<code>capn_ptr</code></li>
<li><code>read_Person()</code>这类函数可以把数据读到结构体中；而<code>write_Person()</code>这类函数可以把结构体数据写到数据段中</li>
</ul>
<details>
  <summary>★这里偷偷折叠了一堆解析源码的凌乱废话笔记，别展开★</summary>
看了它的例子还是没搞懂？那就对了，我也一样

<p>看不清行为就没法往下评估，这货根本没写文档，只能自己读代码了</p>
<p>这些函数和结构体做了什么？</p>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">capn_init_malloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">capn_setp</span><span class="params">()</span></span></span><br><span class="line">capn_ptr类型？</span><br><span class="line">struct capn_segment类型？</span><br></pre></td></tr></tbody></table></figure>

<p>带着问题，去看这个库的实现…</p>
<p><code>sttruct capn</code>：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct capn is a common structure shared between segments in the same</span></span><br><span class="line"><span class="comment"> * session/context so that far pointers between segments will be created.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * lookup is used to lookup segments by id when derefencing a far pointer</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * create is used to create or lookup an alternate segment that has at least</span></span><br><span class="line"><span class="comment"> * sz available (ie returned seg-&gt;len + sz &lt;= seg-&gt;cap)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * create_local is used to create a segment for the copy tree and should be</span></span><br><span class="line"><span class="comment"> * allocated in the local memory space.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocated segments must be zero initialized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * create and lookup can be NULL if you don't need multiple segments and don't</span></span><br><span class="line"><span class="comment"> * want to support copying</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * seglist and copylist are linked lists which can be used to free up segments</span></span><br><span class="line"><span class="comment"> * on cleanup, but should not be modified by the user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * lookup, create, create_local, and user can be set by the user. Other values</span></span><br><span class="line"><span class="comment"> * should be zero initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">capn</span> {</span></span><br><span class="line">	<span class="comment">/* user settable */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *(*<span class="title">lookup</span>)(<span class="title">void</span>* /*<span class="title">user</span>*/, <span class="title">uint32_t</span> /*<span class="title">id</span> */);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *(*<span class="title">create</span>)(<span class="title">void</span>* /*<span class="title">user</span>*/, <span class="title">uint32_t</span> /*<span class="title">id</span> */, <span class="title">int</span> /*<span class="title">sz</span>*/);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *(*<span class="title">create_local</span>)(<span class="title">void</span>* /*<span class="title">user</span>*/, <span class="title">int</span> /*<span class="title">sz</span>*/);</span></span><br><span class="line">	<span class="keyword">void</span> *user;</span><br><span class="line">	<span class="comment">/* zero initialized, user should not modify */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> segnum;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_tree</span> *<span class="title">copy</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_tree</span> *<span class="title">segtree</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *<span class="title">seglist</span>, *<span class="title">lastseg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *<span class="title">copylist</span>;</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>这个capn结构体，可以理解为capn库的共享数据，在多线程环境中为了避免同步操作，所以推荐插在上下文（context）中。</p>
<p><code>struct capn_segment</code>：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* struct capn_segment contains the information about a single segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * capn points to a struct capn that is shared between segments in the</span></span><br><span class="line"><span class="comment"> * same session</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * id specifies the segment id, used for far pointers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * data specifies the segment data. This should not move after creation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * len specifies the current segment length. This is 0 for a blank</span></span><br><span class="line"><span class="comment"> * segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cap specifies the segment capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When creating new structures len will be incremented until it reaches cap,</span></span><br><span class="line"><span class="comment"> * at which point a new segment will be requested via capn-&gt;create. The</span></span><br><span class="line"><span class="comment"> * create callback can either create a new segment or expand an existing</span></span><br><span class="line"><span class="comment"> * one by incrementing cap and returning the expanded segment.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * data, len, and cap must all be 8 byte aligned, hence the ALIGNED_(8) macro</span></span><br><span class="line"><span class="comment"> * on the struct definition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * data, len, cap, and user should all be set by the user. Other values</span></span><br><span class="line"><span class="comment"> * should be zero initialized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">truct <span class="title">ALIGNED_</span><span class="params">(<span class="number">8</span>)</span> capn_segment </span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_tree</span> <span class="title">hdr</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn</span> *<span class="title">capn</span>;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> id;</span><br><span class="line">	<span class="comment">/* user settable */</span></span><br><span class="line">	<span class="keyword">char</span> *data;</span><br><span class="line">	<span class="keyword">size_t</span> len, cap;</span><br><span class="line">	<span class="keyword">void</span> *user;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>翻译：</p>
<blockquote>
<p>struct capn_segment包含单个segment的信息。</p>
<ul>
<li>capn：指向在同session中，可以被多个segment共用的capn结构体</li>
<li>id：指定segment id，用作far pointer</li>
<li>data：指定细分数据。 创建后不应移动。</li>
<li>len：指定当前段的长度。 对于空白段，该值为0。</li>
<li>cap：指定e容量</li>
</ul>
<p>在创建新结构体时，len将递增，直到达到cap，这时将通过<code>capn-&gt;create()</code>请求一个新的段。create回调既可以创建新的细分，也可以通过增加上限并返回扩展的细分来扩展现有细分。</p>
<p>data、len、cap必须全部对齐8个字节，所以使用了ALIGNED_（8）宏。data, len, cap, and user应由用户设置，其他值将初始化为零。</p>
</blockquote>
<p><code>capn_root()</code>做了什么？</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capn_ptr capn<span class="constructor">_root(<span class="params">struct</span> <span class="params">capn</span> <span class="operator">*</span><span class="params">c</span>)</span> {</span><br><span class="line">	capn_ptr r = {CAPN_PTR_LIST};</span><br><span class="line">	r.seg = lookup<span class="constructor">_segment(<span class="params">c</span>, NULL, 0)</span>;</span><br><span class="line">	r.data = r.seg ? r.seg-&gt;data : <span class="keyword">new</span><span class="constructor">_data(<span class="params">c</span>, 8, &amp;<span class="params">r</span>.<span class="params">seg</span>)</span>;</span><br><span class="line">	r.len = <span class="number">1</span>;<span class="operator"></span></span><br><span class="line"><span class="operator">	...</span></span><br><span class="line"><span class="operator"></span>}</span><br></pre></td></tr></tbody></table></figure>

<p>在指定的capn中，找一个id为0的segment，若不存在则创建</p>
<p><code>capn_setp</code>：</p>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* capn_getp|setp functions get/set ptrs in list/structs</span></span><br><span class="line"><span class="comment"> * off is the list index or pointer index in a struct</span></span><br><span class="line"><span class="comment"> * capn_setp will copy the data, create far pointers, etc if the target</span></span><br><span class="line"><span class="comment"> * is in a different segment/context.</span></span><br><span class="line"><span class="comment"> * Both of these will use/return inner pointers for composite lists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">capn_ptr capn<span class="constructor">_getp(<span class="params">capn_ptr</span> <span class="params">p</span>, <span class="params">int</span> <span class="params">off</span>, <span class="params">int</span> <span class="params">resolve</span>)</span>;</span><br><span class="line"><span class="built_in">int</span> capn<span class="constructor">_setp(<span class="params">capn_ptr</span> <span class="params">p</span>, <span class="params">int</span> <span class="params">off</span>, <span class="params">capn_ptr</span> <span class="params">tgt</span>)</span>;</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>capn_getp|setp 函数 get/set 在 list/structs中的指针</p>
<p>off是struct中指针的index，或者list中元素的index</p>
<p>如果target指向不同的segment/context，capn_setp()会复制数据、创建far pointers</p>
<p>capn_getp()函数会返回list的内部指针</p>
</blockquote>
<p>动态内存使用评估，<code>capn-malloc.c: create()</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct capn_segment *<span class="title">create</span><span class="params">(<span class="keyword">void</span> *u, <span class="keyword">uint32_t</span> id, <span class="keyword">int</span> sz)</span> </span>{</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capn_segment</span> *<span class="title">s</span>;</span></span><br><span class="line">	sz += <span class="built_in"><span class="keyword">sizeof</span></span>(*s);</span><br><span class="line">	<span class="keyword">if</span> (sz &lt; <span class="number">4096</span>) {</span><br><span class="line">		sz = <span class="number">4096</span>;</span><br><span class="line">	} <span class="keyword">else</span> {</span><br><span class="line">		sz = (sz + <span class="number">4095</span>) &amp; ~<span class="number">4095</span>;</span><br><span class="line">	}</span><br><span class="line">	s = (struct capn_segment*) <span class="built_in">calloc</span>(<span class="number">1</span>, sz);</span><br><span class="line">	s-&gt;data = (<span class="keyword">char</span>*) (s+<span class="number">1</span>);</span><br><span class="line">	s-&gt;cap = sz - <span class="built_in"><span class="keyword">sizeof</span></span>(*s);</span><br><span class="line">	s-&gt;user = s;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"create()\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结合create函数和segment结构体的注释，可以看出：需要用到动态内存时，每次会申请4KiB内存，不够用时再次申请，这样的机制不会造成我们最担心的堆内存碎片问题；这个4096也可以简单地修改为8字节对齐的数，小内存设备也是可以用的。</p>
</details>



<h2 id="嵌入式场景下评估"><a href="#嵌入式场景下评估" class="headerlink" title="嵌入式场景下评估"></a>嵌入式场景下评估</h2><p>简单评估资源占用，这是我自己用来测试的工程，编码解码测试，算是比较典型的应用，源码就懒得贴了。</p>
<p>编译参数<code>-mcpu=cortex-m4 -mthumb -mfpu=fpv4-sp-d16 -mfloat-abi=hard -ffunction-sections -fdata-sections -Os </code>，用fpvgcc分析：</p>
<figure class="highlight gherkin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+-----+-------+------+-------+</span><br><span class="line">|<span class="string"> FILE                </span>|<span class="string"> VEC </span>|<span class="string">   ROM </span>|<span class="string">  RAM </span>|<span class="string"> TOTAL </span>|</span><br><span class="line">+---------------------+-----+-------+------+-------+</span><br><span class="line">|<span class="string"> libc.a              </span>|<span class="string">     </span>|<span class="string"> 27187 </span>|<span class="string"> 2544 </span>|<span class="string"> 29731 </span>|</span><br><span class="line">|<span class="string"> capn.o              </span>|<span class="string">     </span>|<span class="string">  4374 </span>|<span class="string">      </span>|<span class="string">  4374 </span>|</span><br><span class="line">|<span class="string"> libgcc.a            </span>|<span class="string">     </span>|<span class="string">  3088 </span>|<span class="string">      </span>|<span class="string">  3088 </span>|</span><br><span class="line">|<span class="string"> capn-malloc.o       </span>|<span class="string">     </span>|<span class="string">   971 </span>|<span class="string">      </span>|<span class="string">   971 </span>|</span><br><span class="line">|<span class="string"> capn-stream.o       </span>|<span class="string">     </span>|<span class="string">   758 </span>|<span class="string">      </span>|<span class="string">   758 </span>|</span><br><span class="line">|<span class="string"> main.o              </span>|<span class="string">     </span>|<span class="string">   703 </span>|<span class="string">      </span>|<span class="string">   703 </span>|</span><br><span class="line">|<span class="string"> startup_stm32f4xx.o </span>|<span class="string">     </span>|<span class="string">   462 </span>|<span class="string">      </span>|<span class="string">   462 </span>|</span><br><span class="line">|<span class="string"> nypxdp.capnp.o      </span>|<span class="string">     </span>|<span class="string">   460 </span>|<span class="string">      </span>|<span class="string">   460 </span>|</span><br><span class="line">|<span class="string"> syscall.o           </span>|<span class="string">     </span>|<span class="string">    68 </span>|<span class="string">    4 </span>|<span class="string">    72 </span>|</span><br><span class="line">|<span class="string"> system_stm32f4xx.o  </span>|<span class="string">     </span>|<span class="string">    20 </span>|<span class="string">      </span>|<span class="string">    20 </span>|</span><br><span class="line">|<span class="string"> crtn.o              </span>|<span class="string">     </span>|<span class="string">    16 </span>|<span class="string">      </span>|<span class="string">    16 </span>|</span><br><span class="line">|<span class="string"> crti.o              </span>|<span class="string">     </span>|<span class="string">     8 </span>|<span class="string">      </span>|<span class="string">     8 </span>|</span><br><span class="line">|<span class="string"> TOTALS              </span>|<span class="string">   0 </span>|<span class="string"> 38115 </span>|<span class="string"> 2548 </span>|<span class="string">       </span>|</span><br><span class="line">+---------------------+-----+-------+------+-------+</span><br></pre></td></tr></tbody></table></figure>

<p>关于ROM空间：</p>
<ul>
<li>库本身占用约为6K</li>
<li>由于使用了malloc、printf，libc.a占用了不少空间，其中printf是log打印，可以直接被去掉的；而malloc有精简的替代如<a target="_blank" rel="noopener" href="https://github.com/thi-ng/tinyalloc">tinyalloc</a>仅1.4KB</li>
</ul>
<p>RAM由于未使用静态内存，全是栈、堆上空间这里看不出，通过阅读代码可知：</p>
<ul>
<li>capn为40bytes</li>
<li>每个segment占用64bytes；new对象时，会申请堆内存，首次会申请4K内存（可手动改小），内存不够时再次申请</li>
<li>试考虑“在单个数据包大小为N时，RAM开销是多少”时就要考虑，接收方能不能直接在接收缓存区上解析数据——答案是不能，因为进行序列化并不是简单的内存拷贝（详见<a target="_blank" rel="noopener" href="https://capnproto.org/encoding.html">Serialization Over a Stream</a>）</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>先说结论，它的ROM/RAM开销，运行在一般的ARM Cortex-M核MCU（ROM&lt;32K, RAM&lt;16K这种级别）是没有问题的。</p>
<p>承担着这些额外开销，需要一些理由去用它（或者不用它），毕竟这些ROM/RAM都是实打实的、放在每片芯片上的银子</p>
<p>用它的理由：</p>
<ul>
<li>.capnp文件可以作为协议文档，而且有一定的自解释性</li>
<li>序列化格式的生成、解析无需人工写代码，减少了协议对接错误的可能</li>
<li>与其他编程语言协作起来方便，比如与你硬件设备通讯的是Python、Rust，都能找到对应的实现</li>
</ul>
<p>不用它的理由：</p>
<ul>
<li>它的实现挺复杂，至少不简单，我们的应用真的需要这么完善的序列化格式吗？（类似的序列化<a target="_blank" rel="noopener" href="https://github.com/rtsisyk/msgpuck">MsgPuck</a>虽然功能少，但更加简单而且零开销，但它缺少其他语言的实现、以及像.capnp一样的描述数据结构的文件）</li>
</ul>
<blockquote>
<p>TODO: 遗漏一个评估要点是性能，这得单独开一篇做个基准测试来同JSON(jsmn)/protobuf(nanopb)对比。</p>
</blockquote>

  </div>
  <footer class="article-footer">
    
  <div class="cc">
    <a href="http://creativecommons.org/licenses/by-nc/4.0/deed.z" target="_blank" title="署名-非商业性使用">
      <img src="/images/cc/cc.png">
      
          <img src="/images/cc/by.png">
        
          <img src="/images/cc/nc.png">
        
      <span>
        本作品采用知识共享 署名-非商业性使用 4.0 国际许可协议进行许可。
      </span>
    </a>
  </div>


    

  </footer>
</article>




<section id="comments">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'noodlefighter'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>




          <div class="main-footer">
  
    © 2021 Noodlefighter&#39;s HP - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  
<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>


  
<link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">

  
<link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">


  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  
<script src="/PhotoSwipe/photoswipe.js"></script>

  
<script src="/PhotoSwipe/photoswipe-ui-default.js"></script>




<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>


<script src="/scripts/main.js"></script>


  
<div style="display:none"><script src="https://s4.cnzz.com/z_stat.php?id=5956290&web_id=5956290" language="JavaScript"></script></div>


</body>
</html>
