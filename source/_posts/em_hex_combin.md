title: 将两个HEX文件合并成一个文件的方法
description: 
date: 2015-09-02
layout: post
comments: ture
categories:
- 嵌入式软件
tags: 
- hex
---



# 需求
根据需要，有时候烧入芯片的程序不止一个。
分两次烧入，在批量生产时难操作。

# 解决方法
比如，把程序分成Bootloader和Application两部分
就会产生两个文件Bootloader.hex和Application.hex

两个文件都差不多这种感觉
```
:020000040800F2
:10000000F805002021010008810D0008890B000877
……
:00000001FF
```

## 64k以内的程序
都可以照着以下步骤合并
1. 在文本编辑器中，把第一个文件直接复制到新的文件里
2. 第二个文件，除了首位两行，全部复制，粘贴到新文件里最后一行之前（“:00000001FF”这行之前）

## 64k以上程序
还没有验证

---

附：HEX文件解析(转，简单修改请见谅)
> 引用：http://wojiushiwolxw.spaces.eepw.com.cn/articles/article/item/92621

HEX格式文件以行为单位，每行由“：”（0x3a）开始，以回车键结束(0x0d,0x0a)。
行内的数据都是由两个字符表示一个16进制字节，比如”01”就表示数0x01；”0a”，就表示0x0a。
对于16位的地址，则高位在前低位在后，比如地址0x010a，在HEX格式文件中就表示为字符串”010a”。

每行数据:
```
<0x3a>
[数据长度1Byte]
[数据地址2Byte]
[数据类型1Byte]
[数据nByte]
[校验1Byte]
<0x0d>
<0x0a>
```
 
Example.hex
```
10000000020003787FE4F6D8FD75812B02004A02D6
10001000008FE493A3F8E493A34003F68001F20871
10002000DFF48029E493A3F85407240CC8C333C435
10003000540F4420C8834004F456800146F6DFE4A0
10004000800B01020408102040809000C2E47E0171
100050009360BCA3FF543F30E509541FFEE493A313
1000600060010ECF54C025E060A840B8E493A3FAF7
10007000E493A3F8E493A3C8C582C8CAC583CAF0B1
10008000A3C8C582C8CAC583CADFE9DEE780BEE432
0700F0001F70F31E80F022D7
00000001FF
```

面对这一大串的十六进制码，有没有头昏眼花的感觉呢？
别急别急，经过本文的介绍，你一定会爱上这个会让你头昏眼花的机器码的！
首先我们先介绍HEX文件的编码格式，举范例程序中第一行说明：

1|2|3|4|5|6
--|--|--|--|--|--
:　|10　|0000　|00　|020003787FE4F6D8FD75812B02004A02　|D6 


为了方便解说，笔者将原始码以空格区分成六个部分，在实际转换的原始内容应该没有空格也没有行号的。
## 第1部分
是HEX文件的起始格式，文件一开始应该是一个冒号作为起点；
## 第2部分
两码(10H)所代表的是该行总共具备多少个字节的数据，以本行为例，应该有16个字节，因为10H换算成十进制应该是16；
## 第3部分
四码所代表的是放置数据的开始位置，换句话说，本行的数据应该是放置在0000H～000FH 这段地址中；
## 第4部分
两码是检查码，所代表的是该行数据类型。
```
00 ----数据记录       
01 ----文件结束记录
02 ----扩展段地址记录
04 ----扩展线性地址记录

'00' Data Record
'01' End of File Record
'02' Extended Segment Address Record
'03' Start Segment Address Record
'04' Extended Linear Address Record
'05' Start Linear Address Record
```
这里就是0x00即为普通数据记录。
首先我们只处理数据类型为0x00及0x01的情况。0x02表示对应的存储地址超过了64K，由于我的编程器只针对64K以下的单片机，因此在次不处理，0x04也是如此。
## 第5部分
为数据存放区，总共32码16个字节，有兴趣的可以实际算算看，
这里的机器码已经是标准的MCS-51指令，如果查表的话可以直接知道其功能，稍后的文章会再提到；
## 第6部分
校验值。
什么叫做校验值？所谓的校验值是一种标准的校验码，
把它加在每一行机器码的最后，可以使每一行所有的十六进制值(两个为一组)，
加总后所得到最后两位十六进制码应为00H，
如果你不太会十六进制运算的话，没关系，Windows中有一个很好用的工具叫“计算器”，
你可以切换到科学型计算的十六进制模式，将数值直接输入，它就会自动帮你算好了。
以本例来说，将所有的值相加所得到的值应该是：
10H + 00H + 00H + 00H + 02H + 00H + 03H + 78H + 
7FH + E4H + F6H + D8H+ FDH + 75H + 81H + 2BH + 02H + 
00H + 4AH + 02H + D6H = 700H
最后两个码果然为00H，有兴趣的人可以把范例中的每一行都算算看，结果一定都是这样的。
每个HEX格式的最后一行都是固定为：
:00000001FF

---

参考博文
http://blog.sina.com.cn/s/blog_415be96001018nh7.html
http://wojiushiwolxw.spaces.eepw.com.cn/articles/article/item/92621
